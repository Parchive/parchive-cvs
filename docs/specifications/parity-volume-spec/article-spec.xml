<?xml version="1.0" standalone="no" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V4.1.2.5//EN"
  "http://www.oasis-open.org/docbook/xml/simple/4.1.2.5/sdocbook.dtd" [
  <!ENTITY license SYSTEM "../../licenses/gnu/fdl.xml">
]>
<!--
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
| Parity Archive Volume Specification 2.0
|  $Id$
|
| AUTHORS:
|  Michael Nahas      <mike_nahas@users.sourceforge.net>
|
| CONTRIBUTORS:
|  Peter Clements     <peterclements@users.sourceforge.net>
|  Paul Nettle        <fluidstudios@users.sourceforge.net>
|  Ryan Gallagher     <binerman@users.sourceforge.net>
|
| COPYRIGHT:
|  Copyright (c) 2003, The Authors
|
| LEGAL NOTICE:
|  Permission is granted to copy, distribute and/or modify this document
|  under the terms of the GNU Free Documentation License, Version 1.2
|  or any later version published by the Free Software Foundation;
|  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
|  A copy of the license is included in the section entitled "GNU
|  Free Documentation License".
|
| COPYING:
|  This document is distributed under the GNU Free Documentation License.
|  <http://www.gnu.org/licenses/fdl.html>
|
| FORMATTING:
|  The following document is authored in Docbook Simplified (XML).
|
|  The DTD and other resources can be found here:
|   <http://www.docbook.org/xml/simple/4.1.2.5/index.html>
|
|  Docbook Simplified is a subset of Docbook SGML/XML and can be output
|  with the same tools for that more extensive format.
|
|  For instructions for producing viewable outputs from this format read
|  any of the links below...
|
|  Docbook Definitive Guide:
|   <http://docbook.org/tdg/en/index.html>
|  Chapter on Publishing Docbook:
|   <http://www.oasis-open.org/docbook/documentation/reference/html/ch04.html>
|
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-->
<article>

  <articleinfo>
    <title>Parity Volume Set Specification 2.0</title>
    <!-- {{{ -->
    <pubdate>May 11th, 2003</pubdate>
    <publishername>
      The Parchive Project
      <ulink url="http://parchive.sourceforge.net">http://parchive.sourceforge.net</ulink>
    </publishername>
    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>
        <date>October 14th, 2001</date>
        <revremark>Related specification, Inspiration</revremark>
      </revision>
      <revision>
        <revnumber>2.0</revnumber>
        <date>May 11th, 2003</date>
        <revremark>New Specification, Initial publication and formatting.</revremark>
      </revision>
      <copyright>
        <year>2003</year>
        <holder>The Authors</holder>
      </copyright>
      <legalnotice>
        Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included in the section entitled "GNU Free Documentation License".
      </legalnotice>
    </revhistory>

    <authorgroup>
      <author>
        <firstname>Michael</firstname>
        <surname>Nahas</surname>
        <authorblurb>
          <para>Principle Author</para>
        </authorblurb>
      </author>
    </authorgroup>

    <authorgroup>
      <othercredit>
        <firstname>Peter</firstname>
        <surname>Clements</surname>
        <authorblurb>
          <para>Contributor</para>
        </authorblurb>
      </othercredit>
    </authorgroup>

    <authorgroup>
      <othercredit>
        <firstname>Paul</firstname>
        <surname>Nettle</surname>
        <authorblurb>
          <para>Contributor</para>
        </authorblurb>
      </othercredit>
    </authorgroup>

    <authorgroup>
      <othercredit>
        <firstname>Ryan</firstname>
        <surname>Gallagher</surname>
        <authorblurb>
          <para>Contributor</para>
        </authorblurb>
      </othercredit>
    </authorgroup>
    <!-- }}} -->
  </articleinfo>

  <abstract>
    <!-- {{{ -->
    <para>
      Based on <emphasis>Parity Volume Set Specification 1.0 [2001-10-14]</emphasis> by Stefan Wehlus and others.
    </para>
    <!-- }}} -->
  </abstract>

  <section>
    <title>Introduction</title>
    <!-- {{{ -->
    <para>
      This document describes a file format for storing redundant data for a set of files.
    </para>
    <para>
      In operation, a user will select a set of files from which the redundant data is to be made. These are known as <emphasis>input files</emphasis> and the set of them is known as the <emphasis>recovery set</emphasis>. The user will provide these to a program which generates file(s) that match the specification in this document. The program is known as a <emphasis>PAR 2.0 Client</emphasis> or <emphasis>client</emphasis> for short, and the generated files are known as <emphasis>PAR 2.0 files</emphasis> or <emphasis>PAR files</emphasis>. If the files in the recovery set ever get damaged (e.g.  when they are transmitted or stored on a faulty disk) the client can read the damaged input files, read the (possibly damaged) PAR files, and regenerate the original input files. Of course, not all damages can be repaired, but many can.
    </para>
    <para>
      A user can also name some input files that are not to be recovered if damaged. These input files are known as the <emphasis>non-recovery set</emphasis>. This feature is in the spec to keep the same functionality as PAR 1.0.
    </para>
    <para>
      The redundant data in the PAR files is computed using Reed-Solomon codes. These codes can take a set of equal-sized blocks of data and produce a number of same-sized recovery blocks. Then, given a subset of original data blocks and some recovery block, it is possible to reproduce the original data blocks. Reed-Solomon codes can do this recovery as long as the number of missing data blocks does not out number the recovery blocks. The design of the Reed-Solomon codes in this spec is based on <ulink url="http://www.cs.utk.edu/~plank/plank/papers/SPE-9-97.html">James S. Plank's tech report at U. of Tennessee entitled <emphasis>A tutorial on Reed-Solomon coding for fault-tolerance in RAID-like systems</emphasis></ulink>.  The tech report contains an error, so the design is changed slightly to fix the problem. PAR 2.0 uses a 16-bit Reed-Solomon code and can support 32768 blocks.
    </para>
    <para>
      The equal-sized blocks for the Reed-Solomon codes come from <emphasis>slices</emphasis> of the input files in the recovery set. The slices are consecutive equal-sized chunks of each file. If a file does not fill out the chunk, i.e. <emphasis>it ends mid-slice</emphasis>, the rest of the slice is treated as if it is padded with zero bytes.
    </para>
    <para>
      The PAR 2.0 file itself is made of <emphasis>packets</emphasis> - self-contained parts with their own checksum. This design prevents damage to one part of the file from making the whole file unusable.
    </para>
    <para>
      Packets have a type and each type of packet serves a different purpose. One describes a file. Another contains the checksums of the slices in a file. Another states which files are in the recovery set and which files are in the non-recovery set. And yet another contains a <emphasis>recovery slice</emphasis> - the recovery data produced by the Reed-Solomon code.
    </para>
    <para>
      A PAR 2.0 file is only required to contain 1 specific packet - the packet that identifies the type of client that created the file.  This way, if clients are creating files that don't match the specification in some way, they can be tracked down.
    </para>
    <para>
      The packets for a recovery set and non-recovery set can be broken into multiple files. Files can contain duplicate packets - in fact, this is recommended for vital packets, such as the ones that describe the input files and the one that states which files are in the recovery set. Packets can appear in any order in a file.
    </para>
    <!-- }}} -->
  </section>

  <section>
    <title>Conventions</title>
    <!-- {{{ -->
    <para>
      There are a number of conventions used in the design of this specification.
    </para>
    <para>
      The data is 4-byte aligned. That is, every field starts on an index in the file which is congruent to zero, modulus 4. (I.e., address % 4 == 0) This is because some memory systems function faster if 32-bit quantities are 4-byte aligned. It should be noted that a file could be corrupted (bytes inserted or deleted) to throw off the alignment. The spec is designed so that future versions could be 8-byte aligned.
    </para>
    <para>
      All integers in this version of the spec are unsigned integers of either 4 or 8 bytes in length.
    </para>
    <para>
      Strings are not null-terminated. This is to prevent hackers from using stack-overflow attacks. In order to make a string 4-byte aligned, 1 to 3 zero bytes may be appended. (2 bytes in the case of Unicode strings.) If an N-byte field contains an array, a null-terminated string can be created by copying the N-byte field into a character array of length N+1 and then the setting the N+1 character to '\0'.
    </para>
    <para>
      The lengths of arrays and strings are often implicit. For example, if a region is known to be 32 bytes and that region contains an 8-byte integer and a string, then the string is known to take up 24 bytes. The string is then at least 21 bytes in length, since the 24 bytes contains 0 to 3 bytes of null padding at the end.
    </para>
    <para>
      All strings in the "core" spec are ASCII. This was chosen because Unicode is not sufficiently supported by tools. There exist optional portions of the spec that do support Unicode strings.
    </para>
    <para>
      The lengths of files and parts of files are determined by 8-byte integers. This is to support OSes that can handle files longer than 4GB.
    </para>
    <para>
      All integers are Intel-endian. (That is, little endian.)
    </para>
    <para>
      The recovery set (and non-recovery set, if present) is identified by a 16-byte value known as the Recovery Set ID. Every part of the PAR file that affects a recovery set contains the recovery set ID. In this 2.0 version, the Recovery Set ID is calculated as an MD5 Hash of certain values. The way of calculating this value could change in future versions.
    </para>
    <para>
      Files are also identified by a 16-byte value. In this 2.0 Version, it is an MD5 Hash of their name, length and the MD5 Hash of their first 16kB. The way of calculating this value could change in future versions.
    </para>
    <para>
      Every byte of a PAR file is specified. There are no places to throw junk bytes that can be any value. Padding, where needed, is specified to be zero bytes. The order of items in all arrays is specified.
    </para>
    <para>
      The specification is designed so that if two clients generate a packet with the same parameters, the packets are identical (except for client-identifying or client-specific packets). Thus, client writers can compare the output of their program against the reference implementation by comparing packets byte-for-byte.
    </para>
    <!-- }}} -->
  </section>

  <section>
    <title>Description</title>
    <!-- {{{ -->
    <para>
      A PAR 2.0 file consists of a sequence of "packets". A packet has a fixed sized header and a variable length body. The packet header contains a checksum for the packet - if the packet is damaged, the packet is ignored. The packet header also contains a packet-type. If the client does not understand the packet type, the packet is ignored. To be compliant with this specification, a client must understand the "core" set of packets.  Client may process the optional packets or create their own application-specific packets.
    </para>
    <para>The packet header is:</para>

    <table>
      <title>Packet Header</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Length (bytes)</entry>
            <entry>Type</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>8</entry>
            <entry>byte[8]</entry>
            <entry>Magic sequence. Used to quickly identify location of packets. Value = {'P', 'A', 'R', '2', '\0', 'P', 'K', 'T'} (ASCII) </entry>
          </row>
          <row>
            <entry>8</entry>
            <entry>8-byte uint</entry>
            <entry>Length of the entire packet. Must be multiple of 4. (NB: Includes length of header.)</entry>
          </row>
          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>MD5 Hash of packet. Used as a checksum for the packet. Calculation starts at first byte of Recovery Set ID and ends at last byte of body. <emphasis>Does not include the magic sequence, length field or this field. NB: The MD5 Hash, by its definition, includes the length as if it were appended to the packet.</emphasis></entry>
          </row>
          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>Recovery Set ID. All packets that belong together have the same recovery set ID. (See "main packet" for how it is calculated.)</entry>
          </row>
          <row>
            <entry>16</entry>
            <entry>byte[16]</entry>
            <entry>Type. Can be anything. All beginning "PAR " (ASCII) are reserved for specification-defined packets.  Application-specific packets are recommended to begin with the ASCII name of the client.</entry>
          </row>
          <row>
            <entry>?*4</entry>
            <entry>?</entry>
            <entry>Body of Packet. Must be a multiple of 4 bytes.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      There are various types of packets. The "core" set of packets - the set of packets that all clients must recognize and process - are listed next. For each, the value for the "type" field will be listed along with the contents of the body of the packet.
    </para>

    <section>
      <title>Main packet</title>
      <!-- {{{ -->
      <para>
        The main packet contains the slice size and the File IDs of all the files in the recovery set. The MD5 hash of the <emphasis>body</emphasis> of the main packet is used as the Recovery Set ID, which is included in the packet header of every packet for the set. Clients reading a file should just test that the Recovery Set ID is the same in all packets and not check that it was calculated to the right value; the method for calculating the Recovery Set ID could change in future versions.
      </para>
      <para>
        The main packet has a type value of "PAR 2.0\0Main\0\0\0\0" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>Main packet</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>8</entry>
              <entry>8-byte uint</entry>
              <entry>Slice size. Must be a multiple of 4.</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>4-byte uint</entry>
              <entry>Number of files in the recovery set.</entry>
            </row>
            <row>
              <entry>?*16</entry>
              <entry>MD5 Hash array</entry>
              <entry>File IDs of all files in the recovery set. (See File Description packet.) These hashes are <emphasis>sorted</emphasis> by numerical value (treating them as 16-byte unsigned integers).</entry>
            </row>
            <row>
              <entry>?*16</entry>
              <entry>MD5 Hash array</entry>
              <entry>File IDs of all files in the non-recovery set. (See File Description packet.) These hashes are <emphasis>sorted</emphasis> by numerical value (treating them as 16-byte unsigned integers).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <!-- }}} -->
    </section>

    <section>
      <title>File Description packet</title>
      <!-- {{{ -->
      <para>
        A file description packet is included for each input file - recoverable or non-recoverable. The first thing in the packet is the File ID - this uniquely identifies a file in the PAR file. The packet then contains the MD5 hash, MD5 hash of the first 16kB of the file, file length, and the name of the file.  The MD5 hash of the first 16kB of the file is included so that a client can identify a file if its name has been changed without the client reading the entire file. (Of course, that assumes the first 16kB hasn't been damaged or lost!)
      </para>
      <para>
        The File ID in this version is calculated as the MD5 Hash of the last 3 fields of the body of this packet: MD5-16k, length, and ASCII file name. Note: The length and MD5-16k are included because the Recovery Set ID is a hash of the File IDs and the Recovery Set ID should be a function of file contents as well as names.
      </para>
      <para>
        File names are case sensitive and can be of any length.  If a client is doing recovery on an operating system that has case-insensitive filenames or limited-length filenames, it is up to the client to rename files and directories.  If the file's directory does not exist, the client must create it.
      </para>
      <para>
        The file description packer has a type value of "PAR 2.0\0FileDesc" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>File Descriptor Packet Body Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>The File ID.</entry>
          </row>

          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>The MD5 hash of the entire file.</entry>
          </row>

          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>The MD5-16k. That is, the MD5 hash of the first 16kB of the file.</entry>
          </row>

          <row>
            <entry>8</entry>
            <entry>8-byte uint</entry>
            <entry>Length of the file.</entry>
          </row>

          <row>
            <entry>?*4</entry>
            <entry>ASCII char array</entry>
            <entry>Name of the file. <emphasis>This array is not guaranteed to be null terminated!</emphasis> Subdirectories are indicated by an HTML-style '/' (a.k.a. the UNIX slash). <emphasis>The filename must be unique.</emphasis></entry>
          </row>

          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Input File Slice Checksum packet</title>
      <!-- {{{ -->
      <para>
        This packet type contains checksums for all the slices that are in an input file. It includes a CRC32 checksum to quickly locate the slices and an MD5 checksum to verify they have not been modified. The <ulink url="http://www.ross.net/crc/crcpaper.html">CRC32</ulink> is specified by CCITT and is the same as in Ethernet packets (and PKZIP, FDDI, etc.). If the file would end mid-slice, the remainder of the slice is filled with 0-value bytes.
      </para>
      <para>
        The input file slice checksum packet has a type value of "PAR 2.0\0IFSC\0\0\0\0" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>Slice Checksum Packet Body Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>16</entry>
              <entry>MD5 Hash</entry>
              <entry>The File ID of the file.</entry>
            </row>
            <row>
              <entry>?*20</entry>
              <entry>{MD5 Hash, CRC32} array</entry>
              <entry>MD5 Hash and CRC32 pairs for the slices of the file. The Hash/CRC pairs are in the same order as their respective slices in the file. The Hash comes before the CRC in the array elements.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Recovery Slice packet</title>
      <!-- {{{ -->
      <para>
        The recovery slice packet contains one slice of recovery data. The recovery data is generated using a 16-bit Galois Field (GF) with generator 0x0001100B.
      </para>
      <para>
        The algorithm for computing recovery slices is based on <ulink url="http://www.cs.utk.edu/~plank/plank/papers/SPE-9-97.html">James S. Plank's tech report at U. of Tennessee entitled <emphasis>A tutorial on Reed-Solomon coding for fault-tolerance in RAID-like systems</emphasis></ulink>.  The input slices are ordered and assigned 16-bit constants. Recovery slices are assigned 16-bit exponents. Each 2-byte word of the recovery slice is the sum of the contributions from each input slice.  The contribution of each input slice is the 2-byte word of the input slice multiplied by the input slice's constant raised to the recovery slice's exponent. All these computations (adds, multiplys, powers) are done using the 16-bit Galois Field operations.
      </para>
      <para>
        To generate the recovery data, the slices of the input files are assigned constants. This is based on the order the File IDs appear in the main packet and then by the order the slices appear in the file. So the first slice of the first file in the main packet is assigned the first constant. The second slice of the first file is assigned the second constant. And so on.  If the last slice of the first file has the Nth constant, the first slice of the second file is assigned the (N+1)th. And so on.
      </para>
      <para>
        Here, the PAR 2.0 Spec diverges from <ulink url="http://www.cs.utk.edu/~plank/plank/papers/SPE-9-97.html">Plank's paper</ulink>. In Plank, the first constant is 1, the second 2, the third 3, etc. This is a bad approach because some constants have an order less than 65535. (That is, there exists constants N where N raised to a power less than 65535 is equal to 1 in the Galois Field.) These constants can prevent recovery matrices from being invertible and can, therefore, stop recovery. This spec does not use those constants. So, the first constant is the first power of two that has order 65535. The second constant is the next power of two that has order 65535. And so on. A power of two has order 65535 if the exponent is not equal to 0 modulus 3, 5, 17, or 257. In C code, that would be (n%3 != 0 &amp;&amp; n%5 != 0 &amp;&amp; n%17 != 0 &amp;&amp; n%257 != 0). Note - this is the <emphasis>exponent</emphasis> being tested, and not the constant itself. There are 32768 valid constants. The first few are:
      </para>

      <itemizedlist>
        <listitem>2</listitem>
        <listitem>4</listitem>
        <listitem>16</listitem>
        <listitem>128</listitem>
        <listitem>256</listitem>
        <listitem>2048</listitem>
        <listitem>8192</listitem>
        <listitem>16384</listitem>
        <listitem>4107</listitem>
        <listitem>32856</listitem>
        <listitem>17132 ...</listitem>
      </itemizedlist>

      <para>
        The recovery slice packet has a type value of "PAR 2.0\0RecvSlic" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>Recovery Slice Packet Body Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>4</entry>
              <entry>4-byte unit</entry>
              <entry>Exponent used to generate recovery data</entry>
            </row>
            <row>
              <entry>?*4</entry>
              <entry>byte array</entry>
              <entry>Recovery data.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Creator packet</title>
      <!-- {{{ -->
      <para>
        This packet is used to identify the client that created the file. It is <emphasis>required</emphasis> to be in every PAR file. If a client is unable to process a recovery set, the contents of the creator packet <emphasis>must </emphasis>be shown to the user. The goal of this is that any client incompatibilities can be found and resolved quickly.
      </para>
      <para>
        The creator packet has a type value of "PAR 2.0\0Creator\0" (ASCII). The packet's body contains the following:
      </para>

      <table>
      <title>Creator Packet Body Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>?*4</entry>
              <entry>ASCII char array</entry>
              <entry>ASCII text identifying the client. This should also include a way to contact the client's creator - either through a URL or an email address. NB: <emphasis>This is not a null terminated string!</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <para>
      Here ends the "core" packets that all clients must recognize and process.
    </para>
    <!-- }}} -->
  </section>

  <section>
    <title>Conclusion</title>
    <!-- {{{ -->
    <para>
      That is the official spec. To make sure clients work similarly, the following client conventions should be followed.
    </para>
    <para>
      PAR 2.0 files should always end in ".par2". For example, "file.par2". If a file contains recovery slices, the ".par2" should be preceded by ".volXX-YY" where XX to YY is the range of exponents for the recovery slices. For example, "file.vol20-29.par2". More than 2 digits should be used if necessary. Any exponents that contain fewer digits than the largest exponent should be preceded by zeros so that all filenames have the same length. For example, "file.vol075-149.par2".  Exponents should start at 0 and go upwards.
    </para>
    <para>
      If multiple PAR files are generated, they may either have a constant number of slices per file (e.g. 20, 20, 20, ...) or exponentially increasing number of slices (e.g., 1, 2, 4, 8, ...).  Note that to store 1023 slices takes 52 files if each has 20 slices, but takes only 10 files with the exponential pattern.
    </para>
    <para>
      When generating multiple PAR files, it is expected that one file be generated without any slices and containing all main, file description, and input file checksum packets. The other files should also include the main, file description and input file checksum packets. This repeats data that cannot be recovered.
    </para>
    <para>
      <emphasis>NOTE: If the files are to be transmitted over usenet, it might be best to place the main, file description and input file checksum packets at the end, so that the equal-sized recovery slice packets are at the beginning. That way it may be possible to put a single recovery slice in each usenet message.</emphasis>
    </para>
    <para>
      If just a single PAR file is generated, it is expected that the main, file description, and input file checksum packets are repeated multiple times and scattered through out the file. (Once again, repeating data that cannot be recovered.)
    </para>
    <para>
      Recall that all files <emphasis>must</emphasis> contain a creator packet.
    </para>
    <para>
      It is recommended that users are warned when they create PAR files with names that are incompatible with Windows, Mac, or Linux systems.  That is, file or directory names that are more than 255 characters long, start with a period (.) or a dash (-), or contain one of these characters: &lt; &gt; : " ' ` ? * &amp; | [ ] \ ; or newline (\n).
    </para>
    <para>
      It is <emphasis>strongly</emphasis> recommended that clients query a user before writing to a file whose File Description packet contains an absolute pathname. For Windows, that means one starting with "C:\" or "//" for example. For UNIX, that means one starting with "/" or "//". For Mac, that means one starting with ":". This is to prevent PAR files of unknown origin from cracking a system by overwriting system files.
    </para>
    <!-- }}} -->
  </section>

  <appendix id="appa">
    <title>Optional PAR 2.0 Packets</title>
    <!-- {{{ -->

    <para>
      Clients do not need to process these packets. They are included in this spec because many clients might want to implement the functionality and, if they did, it would be good if they were compatible with each other.
    </para>

    <section>
      <title>Unicode Filename packet</title>
      <!-- {{{ -->

      <para>
        This packet provides an alternate name for a file. This packet <emphasis>overrides</emphasis> the default "ASCII" name in the file description packet.
      </para>
      <para>
        The Unicode filename packet has a type value of "PAR 2.0\0UniFileN" (ASCII, ironically). The packet's body contains the following:
      </para>

      <table>
        <title>Unicode Filename Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>16</entry>
              <entry>MD5 Hash</entry>
              <entry>The File ID of the file.</entry>
            </row>
            <row>
              <entry>?*4</entry>
              <entry>Unicode char array</entry>
              <entry>The name of the file in Unicode. <emphasis>NB: This is not a null terminated array!</emphasis> This name must obey all the restrictions of the ASCII filename in the File Description packet.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>ASCII Comment packet</title>
      <!-- {{{ -->

      <para>
        The ASCII comment packet contains - would you believe it - a comment in ASCII text! This should be shown to the user. If multiple copies of the same comment are found, only one need be shown.
      </para>
      <para>
        The ASCII comment packet has a type value of "PAR 2.0\0CommASCI" (ASCII). The packet's body contains the following
      </para>

      <table>
        <title>ASCII Comment Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>?*4</entry>
              <entry>ASCII char array</entry>
              <entry>The comment. NB: <emphasis>This is not a null terminated string!</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Unicode Comment packet</title>
      <!-- {{{ -->

      <para>
        The Unicode comment packet contains a comment in Unicode text. This should be shown to the user. If multiple copies of the same comment are found, only one need be shown. If an analogous ASCII version of the same comment is included in the file, the ASCII comment should not be shown.
      </para>
      <para>
        The Unicode comment packet has a type value of "PAR 2.0\0CommUni" (ASCII, ironically). The packet's body contains the following:
      </para>

      <table>
        <title>Unicode Comment Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>16</entry>
              <entry>MD5 Hash or zeros</entry>
              <entry>If an ASCII comment packet exists in the file and is just a translation of the Unicode in this comment, this is the MD5 Hash of the ASCII comment packet. Otherwise, it is zeros.</entry>
            </row>
            <row>
              <entry>?*4</entry>
              <entry>Unicode char array</entry>
              <entry>The comment. NB: <emphasis>This is not a null terminated string!</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Input File Slice packet</title>
      <!-- {{{ -->

      <para>
        The input file slice packet is used if the user wants to include the input file inside the PAR file. This can be used to combine lots of small files into one file or to break a large file into smaller files (by distributing its slices into many PAR files). The length of the slice is determined by the slice size in the main packet, unless the slice would run off the end of the file. The packet contains an index for the slice and the slice contain bytes from (slice_size*index) to (slice_size*index + slice_size -1), unless the end of the file is reached. <emphasis>NOTE: The indices are not the same as the input slice constants used in making recovery slices.</emphasis>
      </para>
      <para>
        If files contain input slices, the ".par2" in the filename should be preceded by ".partXX-YY" where XX to YY is the indices of the slices.  For example, "file.part00-09.par2" Indices are assigned to slices in the same order that constants were assigned in generating the recover packets. "... <emphasis>based on the order the File IDs appear in the main packet and then by the order the slices appear in the file. So the first slice of the first file in the main packet is assigned the first constant. The second slice of the first file is assigned the second constant. And so on. If the last slice of the first file has the Nth constant, the first slice of the second file is assigned the (N+1)th. And so on.</emphasis>"
      </para>
      <para>
        The input file slice packet has a type value of "PAR 2.0\0FileSlic". The packet's body contains the following:
      </para>

      <table>
        <title>Input File Slice Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>16</entry>
              <entry>MD5 Hash</entry>
              <entry>The File ID of the file.</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>8-byte uint</entry>
              <entry>The index of the slice. (See description above.)</entry>
            </row>
            <row>
              <entry>?*4</entry>
              <entry>byte array</entry>
              <entry>The slice. If the file ends mid-slice, the field is zero padded with 0 to 3 bytes to make it end on a 4-byte alignment.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Recovery File Slice Checksum packet</title>
      <!-- {{{ -->
      <para>
        So far, we've had input and recovery slices in the PAR file and input slices in an external file (i.e., the input file slice checksum packet). This packet covers the last combination - the recovery slices are in an external file (i.e., one where they don't have packet headers). This packet type may never be used, but it is included for completeness.
      </para>
      <para>
        There exists a file description packet for the file. The slices are generated the same as for the recovery slice packet.
      </para>
      <para>
        The recovery file slice checksum packet has a type value of "PAR 2.0\0RFSC\0\0\0\0". The packet's body contains the following:
      </para>

      <table>
        <title>Recovery File Slice Checksum Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>16</entry>
              <entry>MD5 Hash</entry>
              <entry>The File ID of the file.</entry>
            </row>
            <row>
              <entry>?*24</entry>
              <entry>{MD5 Hash, CRC32, 4-byte uint} array</entry>
              <entry>MD5 Hash, CRC32, and exponent triplets for the slices in the file. The Hash/CRC/exponent triplets are in the same order as their respective slices in the file. The order in the array element is MD5 Hash, CRC32, followed by exponent.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Packed Main packet</title>
      <!-- {{{ -->
      <para>
        The packed main packet replaces the main packet when the client generates packed recover slice packets. The packed format allows recovery on units smaller than the slice size, which both increases the chance of recovery and allows more than 32,768 files. (The non-packed format requires, for each file, at least one slice and the number of slices is limited to 32,768.)
      </para>
      <para>
        The only difference from the main packet is the addition of the subslice size. (See the description of packed recovery slice packets to see how this is used.)
      </para>
      <para>
        The main packet has a type value of "PAR 2.0\0PkdMain\0" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>Packed Main Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>8</entry>
              <entry>8-byte uint</entry>
              <entry>Subslice size. Must be a multiple of 4. Must equally divide the slice size.</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>8-byte uint</entry>
              <entry>Slice size. Must be a multiple of 4 and a multiple of the subslice size.</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>4-byte uint</entry>
              <entry>Number of files in the recovery set.</entry>
            </row>
            <row>
              <entry>?*16</entry>
              <entry>MD5 Hash array</entry>
              <entry>File IDs of all files in the recovery set. (See File Description packet.) These hashes are <emphasis>sorted</emphasis> by numerical value (treating them as 16-byte unsigned integers).</entry>
            </row>
            <row>
              <entry>?*16</entry>
              <entry>MD5 Hash array</entry>
              <entry>File IDs of all files in the non-recovery set. (See File Description packet.) These hashes are <emphasis>sorted</emphasis> by numerical value (treating them as 16-byte unsigned integers).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <section>
      <title>Packed Recovery Slice packet</title>
      <!-- {{{ -->

      <para>
        The packed recovery slice packet contains one slice of recovery data. The recovery data is generated in the same manner as the recovery slice packet; the only thing that differs is how the data from the input slices is laid out.
      </para>
      <para>
        Files are broken into subslices and the subslices are ordered, just as in the recovery slice packet - sorted first by the order of the File ID in the packed main packet and then by the order of the subslice within the file.
      </para>
      <para>
        These subslices are then grouped to together to make up the slices of input data used in the calculations. If X is the number of subslices in a slice, the first X subslices make up the first slice (which has the recovery constant 2). The next X subslices make up the second slice (which has the constant 4). Etc.
      </para>
      <para>
        In short, the input slices are made by packing the files together, with files starting on subslice boundaries rather than slice boundaries. Note that there are no subslice checksums, but there are file checksums, which can be used to detect bad regions that are smaller than a slice.
      </para>
      <para>
        The recovery slice packet has a type value of "PAR 2.0\0PkdRecvS" (ASCII). The packet's body contains the following:
      </para>

      <table>
        <title>Packed Recovery Slice Packet Contents</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Length (bytes)</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>4</entry>
              <entry>4-byte uint</entry>
              <entry>Exponent used to generate recovery data</entry>
            </row>
            <row>
              <entry>?*4</entry>
              <entry>byte array</entry>
              <entry>Recovery data.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!-- }}} -->
    </section>

    <para>
      This ends the optional packets in this specification.
    </para>

    <!-- }}} -->
  </appendix>

  <appendix id="appb">
    <title>How to Add an Application-Specific Packet Type</title>
    <!-- {{{ -->
    <para>
      Say the author of "NewsPost" wanted to add his own packet type - one that identified the names of the Usenet messages in which the files are posted. That author can create his own packet type. For example, here is the layout for one where the Usenet messages are identified by a newsgroup and a regular expression which all matches the names of the usenet articles.
    </para>
    <para>
      The packet has a type value of "NewsPostUsenet\0\0".  (NB: Including the name of the client in the type is the recommended way to ensure unique type names.) The packet's body contains the following:
    </para>

    <table>
      <title>Example Application Specific Packet</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Length (bytes)</entry>
            <entry>Type</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>16</entry>
            <entry>MD5 Hash</entry>
            <entry>The File ID of the file.</entry>
          </row>
          <row>
            <entry>4</entry>
            <entry>4-byte uint</entry>
            <entry>The length of the string containing the name of the newsgroup. Must be a multiple of 4.</entry>
          </row>
          <row>
            <entry>?*4</entry>
            <entry>ASCII char array</entry>
            <entry>The name of the newsgroup. For example, "alt.binaries.multimedia".</entry>
          </row>
          <row>
            <entry>?*4</entry>
            <entry>ASCII char array</entry>
            <entry>A regular expression matching the name of articles containing the file. For example, "Unaired Pilot - VCD,NTSC - (??/??)".</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <!-- }}} -->
  </appendix>

  <!-- include the GNU FDL license per license requirements -->
  &license;

</article>
